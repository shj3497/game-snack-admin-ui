/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * ÌïÄÌîåÎ°úÏö∞ ÌîÑÎ°úÎ™®ÏÖò: Admin API
 * ÌïÄÌîåÎ°úÏö∞ ÌîÑÎ°úÎ™®ÏÖò: Admin API Î¨∏ÏÑú
 * OpenAPI spec version: 1.0
 */
import {useMutation, useQuery} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CatchEventCreateRequest,
  CatchEventUpdateRequest,
  DrawEventCreateRequest,
  DrawEventUpdateRequest,
  EmptyResponse,
  EventAdminDetailResponse,
  EventAdminListResponse,
  FindEventCreateRequest,
  FindEventUpdateRequest,
  GetEventListParams,
  ImageUploadRequest,
  ImageUploadResponse,
  RouletteEventCreateRequest,
  RouletteEventUpdateRequest,
} from '.././model';

import {customFetch} from '../../custom-fetch.server';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Ïï±Ïóê Îì±Î°ùÎêú Ïù¥Î≤§Ìä∏Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Roulette
 */
export const getUpdateRouletteEventUrl = (appId: string, eventId: string) => {
  return `/admin/api/events/roulette/${appId}/${eventId}`;
};

export const updateRouletteEvent = async (
  appId: string,
  eventId: string,
  rouletteEventUpdateRequest: RouletteEventUpdateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getUpdateRouletteEventUrl(appId, eventId), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(rouletteEventUpdateRequest),
  });
};

export const getUpdateRouletteEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRouletteEvent>>,
    TError,
    {appId: string; eventId: string; data: RouletteEventUpdateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRouletteEvent>>,
  TError,
  {appId: string; eventId: string; data: RouletteEventUpdateRequest},
  TContext
> => {
  const mutationKey = ['updateRouletteEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRouletteEvent>>,
    {appId: string; eventId: string; data: RouletteEventUpdateRequest}
  > = (props) => {
    const {appId, eventId, data} = props ?? {};

    return updateRouletteEvent(appId, eventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateRouletteEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRouletteEvent>>
>;
export type UpdateRouletteEventMutationBody = RouletteEventUpdateRequest;
export type UpdateRouletteEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Roulette
 */
export const useUpdateRouletteEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRouletteEvent>>,
      TError,
      {appId: string; eventId: string; data: RouletteEventUpdateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRouletteEvent>>,
  TError,
  {appId: string; eventId: string; data: RouletteEventUpdateRequest},
  TContext
> => {
  const mutationOptions = getUpdateRouletteEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Îì±Î°ùÎêú Ïù¥Î≤§Ìä∏Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Find
 */
export const getUpdateFindEventUrl = (appId: string, eventId: string) => {
  return `/admin/api/events/find/${appId}/${eventId}`;
};

export const updateFindEvent = async (
  appId: string,
  eventId: string,
  findEventUpdateRequest: FindEventUpdateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getUpdateFindEventUrl(appId, eventId), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(findEventUpdateRequest),
  });
};

export const getUpdateFindEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFindEvent>>,
    TError,
    {appId: string; eventId: string; data: FindEventUpdateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFindEvent>>,
  TError,
  {appId: string; eventId: string; data: FindEventUpdateRequest},
  TContext
> => {
  const mutationKey = ['updateFindEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFindEvent>>,
    {appId: string; eventId: string; data: FindEventUpdateRequest}
  > = (props) => {
    const {appId, eventId, data} = props ?? {};

    return updateFindEvent(appId, eventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateFindEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFindEvent>>
>;
export type UpdateFindEventMutationBody = FindEventUpdateRequest;
export type UpdateFindEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Find
 */
export const useUpdateFindEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFindEvent>>,
      TError,
      {appId: string; eventId: string; data: FindEventUpdateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateFindEvent>>,
  TError,
  {appId: string; eventId: string; data: FindEventUpdateRequest},
  TContext
> => {
  const mutationOptions = getUpdateFindEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Îì±Î°ùÎêú Ïù¥Î≤§Ìä∏Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Draw
 */
export const getUpdateDrawEventUrl = (appId: string, eventId: string) => {
  return `/admin/api/events/draw/${appId}/${eventId}`;
};

export const updateDrawEvent = async (
  appId: string,
  eventId: string,
  drawEventUpdateRequest: DrawEventUpdateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getUpdateDrawEventUrl(appId, eventId), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(drawEventUpdateRequest),
  });
};

export const getUpdateDrawEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDrawEvent>>,
    TError,
    {appId: string; eventId: string; data: DrawEventUpdateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDrawEvent>>,
  TError,
  {appId: string; eventId: string; data: DrawEventUpdateRequest},
  TContext
> => {
  const mutationKey = ['updateDrawEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDrawEvent>>,
    {appId: string; eventId: string; data: DrawEventUpdateRequest}
  > = (props) => {
    const {appId, eventId, data} = props ?? {};

    return updateDrawEvent(appId, eventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateDrawEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDrawEvent>>
>;
export type UpdateDrawEventMutationBody = DrawEventUpdateRequest;
export type UpdateDrawEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Draw
 */
export const useUpdateDrawEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDrawEvent>>,
      TError,
      {appId: string; eventId: string; data: DrawEventUpdateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDrawEvent>>,
  TError,
  {appId: string; eventId: string; data: DrawEventUpdateRequest},
  TContext
> => {
  const mutationOptions = getUpdateDrawEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Îì±Î°ùÎêú Ïù¥Î≤§Ìä∏Î•º ÏàòÏ†ïÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Catch
 */
export const getUpdateCatchEventUrl = (appId: string, eventId: string) => {
  return `/admin/api/events/catch/${appId}/${eventId}`;
};

export const updateCatchEvent = async (
  appId: string,
  eventId: string,
  catchEventUpdateRequest: CatchEventUpdateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getUpdateCatchEventUrl(appId, eventId), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(catchEventUpdateRequest),
  });
};

export const getUpdateCatchEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCatchEvent>>,
    TError,
    {appId: string; eventId: string; data: CatchEventUpdateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCatchEvent>>,
  TError,
  {appId: string; eventId: string; data: CatchEventUpdateRequest},
  TContext
> => {
  const mutationKey = ['updateCatchEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCatchEvent>>,
    {appId: string; eventId: string; data: CatchEventUpdateRequest}
  > = (props) => {
    const {appId, eventId, data} = props ?? {};

    return updateCatchEvent(appId, eventId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateCatchEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCatchEvent>>
>;
export type UpdateCatchEventMutationBody = CatchEventUpdateRequest;
export type UpdateCatchEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ ÏàòÏ†ï - Catch
 */
export const useUpdateCatchEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCatchEvent>>,
      TError,
      {appId: string; eventId: string; data: CatchEventUpdateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCatchEvent>>,
  TError,
  {appId: string; eventId: string; data: CatchEventUpdateRequest},
  TContext
> => {
  const mutationOptions = getUpdateCatchEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïù¥Î≤§Ìä∏ Ïù¥ÎØ∏ÏßÄÎ•º S3Ïóê ÏóÖÎ°úÎìúÌï©ÎãàÎã§.
Î∞òÌôòÎêú Ïù¥ÎØ∏ÏßÄ URLÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïù¥Î≤§Ìä∏Î•º ÏÉùÏÑ±Ìï† Ïàò ÏûàÏäµÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
 */
export const getUploadImageUrl = () => {
  return `/admin/api/events/upload/image`;
};

export const uploadImage = async (
  imageUploadRequest: ImageUploadRequest,
  options?: RequestInit,
): Promise<ImageUploadResponse> => {
  const formData = new FormData();
  formData.append('file', imageUploadRequest.file);

  return customFetch<ImageUploadResponse>(getUploadImageUrl(), {
    ...options,
    method: 'POST',
    body: formData,
  });
};

export const getUploadImageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadImage>>,
    TError,
    {data: ImageUploadRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadImage>>,
  TError,
  {data: ImageUploadRequest},
  TContext
> => {
  const mutationKey = ['uploadImage'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadImage>>,
    {data: ImageUploadRequest}
  > = (props) => {
    const {data} = props ?? {};

    return uploadImage(data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UploadImageMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadImage>>
>;
export type UploadImageMutationBody = ImageUploadRequest;
export type UploadImageMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú
 */
export const useUploadImage = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadImage>>,
      TError,
      {data: ImageUploadRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadImage>>,
  TError,
  {data: ImageUploadRequest},
  TContext
> => {
  const mutationOptions = getUploadImageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Ïù¥Î≤§Ìä∏Î•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Roulette
 */
export const getCreateRouletteEventUrl = (appId: string) => {
  return `/admin/api/events/roulette/${appId}`;
};

export const createRouletteEvent = async (
  appId: string,
  rouletteEventCreateRequest: RouletteEventCreateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getCreateRouletteEventUrl(appId), {
    ...options,
    method: 'POST',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(rouletteEventCreateRequest),
  });
};

export const getCreateRouletteEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRouletteEvent>>,
    TError,
    {appId: string; data: RouletteEventCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRouletteEvent>>,
  TError,
  {appId: string; data: RouletteEventCreateRequest},
  TContext
> => {
  const mutationKey = ['createRouletteEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRouletteEvent>>,
    {appId: string; data: RouletteEventCreateRequest}
  > = (props) => {
    const {appId, data} = props ?? {};

    return createRouletteEvent(appId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type CreateRouletteEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRouletteEvent>>
>;
export type CreateRouletteEventMutationBody = RouletteEventCreateRequest;
export type CreateRouletteEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Roulette
 */
export const useCreateRouletteEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRouletteEvent>>,
      TError,
      {appId: string; data: RouletteEventCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createRouletteEvent>>,
  TError,
  {appId: string; data: RouletteEventCreateRequest},
  TContext
> => {
  const mutationOptions = getCreateRouletteEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Ïù¥Î≤§Ìä∏Î•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Find
 */
export const getCreateFindEventUrl = (appId: string) => {
  return `/admin/api/events/find/${appId}`;
};

export const createFindEvent = async (
  appId: string,
  findEventCreateRequest: FindEventCreateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getCreateFindEventUrl(appId), {
    ...options,
    method: 'POST',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(findEventCreateRequest),
  });
};

export const getCreateFindEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFindEvent>>,
    TError,
    {appId: string; data: FindEventCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFindEvent>>,
  TError,
  {appId: string; data: FindEventCreateRequest},
  TContext
> => {
  const mutationKey = ['createFindEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFindEvent>>,
    {appId: string; data: FindEventCreateRequest}
  > = (props) => {
    const {appId, data} = props ?? {};

    return createFindEvent(appId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type CreateFindEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFindEvent>>
>;
export type CreateFindEventMutationBody = FindEventCreateRequest;
export type CreateFindEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Find
 */
export const useCreateFindEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFindEvent>>,
      TError,
      {appId: string; data: FindEventCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createFindEvent>>,
  TError,
  {appId: string; data: FindEventCreateRequest},
  TContext
> => {
  const mutationOptions = getCreateFindEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Ïù¥Î≤§Ìä∏Î•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Draw
 */
export const getCreateDrawEventUrl = (appId: string) => {
  return `/admin/api/events/draw/${appId}`;
};

export const createDrawEvent = async (
  appId: string,
  drawEventCreateRequest: DrawEventCreateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getCreateDrawEventUrl(appId), {
    ...options,
    method: 'POST',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(drawEventCreateRequest),
  });
};

export const getCreateDrawEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDrawEvent>>,
    TError,
    {appId: string; data: DrawEventCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDrawEvent>>,
  TError,
  {appId: string; data: DrawEventCreateRequest},
  TContext
> => {
  const mutationKey = ['createDrawEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDrawEvent>>,
    {appId: string; data: DrawEventCreateRequest}
  > = (props) => {
    const {appId, data} = props ?? {};

    return createDrawEvent(appId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type CreateDrawEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDrawEvent>>
>;
export type CreateDrawEventMutationBody = DrawEventCreateRequest;
export type CreateDrawEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Draw
 */
export const useCreateDrawEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDrawEvent>>,
      TError,
      {appId: string; data: DrawEventCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDrawEvent>>,
  TError,
  {appId: string; data: DrawEventCreateRequest},
  TContext
> => {
  const mutationOptions = getCreateDrawEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Ïù¥Î≤§Ìä∏Î•º Îì±Î°ùÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Catch
 */
export const getCreateCatchEventUrl = (appId: string) => {
  return `/admin/api/events/catch/${appId}`;
};

export const createCatchEvent = async (
  appId: string,
  catchEventCreateRequest: CatchEventCreateRequest,
  options?: RequestInit,
): Promise<EmptyResponse> => {
  return customFetch<EmptyResponse>(getCreateCatchEventUrl(appId), {
    ...options,
    method: 'POST',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(catchEventCreateRequest),
  });
};

export const getCreateCatchEventMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCatchEvent>>,
    TError,
    {appId: string; data: CatchEventCreateRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCatchEvent>>,
  TError,
  {appId: string; data: CatchEventCreateRequest},
  TContext
> => {
  const mutationKey = ['createCatchEvent'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCatchEvent>>,
    {appId: string; data: CatchEventCreateRequest}
  > = (props) => {
    const {appId, data} = props ?? {};

    return createCatchEvent(appId, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type CreateCatchEventMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCatchEvent>>
>;
export type CreateCatchEventMutationBody = CatchEventCreateRequest;
export type CreateCatchEventMutationError = unknown;

/**
 * @summary Ïù¥Î≤§Ìä∏ Ïã†Í∑ú Îì±Î°ù - Catch
 */
export const useCreateCatchEvent = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCatchEvent>>,
      TError,
      {appId: string; data: CatchEventCreateRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCatchEvent>>,
  TError,
  {appId: string; data: CatchEventCreateRequest},
  TContext
> => {
  const mutationOptions = getCreateCatchEventMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Ïï±Ïóê Îì±Î°ùÎêú Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏
 */
export const getGetEventDetailUrl = (appId: string, eventId: string) => {
  return `/admin/api/events/${appId}/${eventId}`;
};

export const getEventDetail = async (
  appId: string,
  eventId: string,
  options?: RequestInit,
): Promise<EventAdminDetailResponse> => {
  return customFetch<EventAdminDetailResponse>(
    getGetEventDetailUrl(appId, eventId),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getGetEventDetailQueryKey = (appId: string, eventId: string) => {
  return [`/admin/api/events/${appId}/${eventId}`] as const;
};

export const getGetEventDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  appId: string,
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventDetailQueryKey(appId, eventId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventDetail>>> = ({
    signal,
  }) => getEventDetail(appId, eventId, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!(appId && eventId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventDetail>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetEventDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventDetail>>
>;
export type GetEventDetailQueryError = unknown;

export function useGetEventDetail<
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  appId: string,
  eventId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDetail>>,
          TError,
          Awaited<ReturnType<typeof getEventDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventDetail<
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  appId: string,
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventDetail>>,
          TError,
          Awaited<ReturnType<typeof getEventDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetEventDetail<
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  appId: string,
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏
 */

export function useGetEventDetail<
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  appId: string,
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventDetailQueryOptions(appId, eventId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏
 */
export const prefetchGetEventDetail = async <
  TData = Awaited<ReturnType<typeof getEventDetail>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  appId: string,
  eventId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetEventDetailQueryOptions(appId, eventId, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * ÌïÑÌÑ∞ÏôÄ ÌéòÏù¥Ïßï Ï†ïÎ≥¥Î•º Í∏∞Î∞òÏúºÎ°ú Ïù¥Î≤§Ìä∏ Î™©Î°ùÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.<br/><br/>- ÌïÑÌÑ∞ Ï°∞Í±¥ÏùÄ JSON ÌòïÏãùÏúºÎ°ú Ï†ÑÎã¨Îê©ÎãàÎã§.
 * @summary Ïù¥Î≤§Ìä∏ Î™©Î°ù Ï°∞Ìöå
 */
export const getGetEventListUrl = (
  appId: string,
  params?: GetEventListParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/admin/api/events/${appId}/list?${stringifiedParams}`
    : `/admin/api/events/${appId}/list`;
};

export const getEventList = async (
  appId: string,
  params?: GetEventListParams,
  options?: RequestInit,
): Promise<EventAdminListResponse> => {
  return customFetch<EventAdminListResponse>(
    getGetEventListUrl(appId, params),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getGetEventListQueryKey = (
  appId: string,
  params?: GetEventListParams,
) => {
  return [
    `/admin/api/events/${appId}/list`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetEventListQueryOptions = <
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetEventListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetEventListQueryKey(appId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEventList>>> = ({
    signal,
  }) => getEventList(appId, params, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getEventList>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetEventListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEventList>>
>;
export type GetEventListQueryError = unknown;

export function useGetEventList<
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  appId: string,
  params: undefined | GetEventListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventList>>,
          TError,
          Awaited<ReturnType<typeof getEventList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetEventList<
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetEventListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getEventList>>,
          TError,
          Awaited<ReturnType<typeof getEventList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetEventList<
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetEventListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary Ïù¥Î≤§Ìä∏ Î™©Î°ù Ï°∞Ìöå
 */

export function useGetEventList<
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetEventListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetEventListQueryOptions(appId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Ïù¥Î≤§Ìä∏ Î™©Î°ù Ï°∞Ìöå
 */
export const prefetchGetEventList = async <
  TData = Awaited<ReturnType<typeof getEventList>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  appId: string,
  params?: GetEventListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getEventList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetEventListQueryOptions(appId, params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
