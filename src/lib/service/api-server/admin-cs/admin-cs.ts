/**
 * Generated by orval v7.8.0 🍺
 * Do not edit manually.
 * 핀플로우 프로모션: Admin API
 * 핀플로우 프로모션: Admin API 문서
 * OpenAPI spec version: 1.0
 */
import {useMutation, useQuery} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  BooleanResponse,
  CSAnswerRequest,
  CSListResponse,
  CSStatusRequest,
  CSViewResponse,
  GetCSListAllParams,
  GetCSListAllStatusParams,
  GetCSListParams,
  GetCSListStatusParams,
} from '.././model';

import {customFetch} from '../../custom-fetch.server';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * 특정 CS의 상태와 메모를 업데이트합니다.
 * @summary CS 상태 및 메모 업데이트
 */
export const getUpdateCSStatusUrl = (appId: string, id: string) => {
  return `/admin/api/cs/${appId}/status/${id}`;
};

export const updateCSStatus = async (
  appId: string,
  id: string,
  cSStatusRequest: CSStatusRequest,
  options?: RequestInit,
): Promise<CSViewResponse> => {
  return customFetch<CSViewResponse>(getUpdateCSStatusUrl(appId, id), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(cSStatusRequest),
  });
};

export const getUpdateCSStatusMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCSStatus>>,
    TError,
    {appId: string; id: string; data: CSStatusRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCSStatus>>,
  TError,
  {appId: string; id: string; data: CSStatusRequest},
  TContext
> => {
  const mutationKey = ['updateCSStatus'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCSStatus>>,
    {appId: string; id: string; data: CSStatusRequest}
  > = (props) => {
    const {appId, id, data} = props ?? {};

    return updateCSStatus(appId, id, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateCSStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCSStatus>>
>;
export type UpdateCSStatusMutationBody = CSStatusRequest;
export type UpdateCSStatusMutationError = unknown;

/**
 * @summary CS 상태 및 메모 업데이트
 */
export const useUpdateCSStatus = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCSStatus>>,
      TError,
      {appId: string; id: string; data: CSStatusRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCSStatus>>,
  TError,
  {appId: string; id: string; data: CSStatusRequest},
  TContext
> => {
  const mutationOptions = getUpdateCSStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 특정 CS의 답변과 답변자 이름을 업데이트합니다.
 * @summary CS 답변 업데이트
 */
export const getUpdateCSAnswerUrl = (appId: string, id: string) => {
  return `/admin/api/cs/${appId}/answer/${id}`;
};

export const updateCSAnswer = async (
  appId: string,
  id: string,
  cSAnswerRequest: CSAnswerRequest,
  options?: RequestInit,
): Promise<CSViewResponse> => {
  return customFetch<CSViewResponse>(getUpdateCSAnswerUrl(appId, id), {
    ...options,
    method: 'PUT',
    headers: {'Content-Type': 'application/json', ...options?.headers},
    body: JSON.stringify(cSAnswerRequest),
  });
};

export const getUpdateCSAnswerMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCSAnswer>>,
    TError,
    {appId: string; id: string; data: CSAnswerRequest},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCSAnswer>>,
  TError,
  {appId: string; id: string; data: CSAnswerRequest},
  TContext
> => {
  const mutationKey = ['updateCSAnswer'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCSAnswer>>,
    {appId: string; id: string; data: CSAnswerRequest}
  > = (props) => {
    const {appId, id, data} = props ?? {};

    return updateCSAnswer(appId, id, data, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type UpdateCSAnswerMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCSAnswer>>
>;
export type UpdateCSAnswerMutationBody = CSAnswerRequest;
export type UpdateCSAnswerMutationError = unknown;

/**
 * @summary CS 답변 업데이트
 */
export const useUpdateCSAnswer = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCSAnswer>>,
      TError,
      {appId: string; id: string; data: CSAnswerRequest},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCSAnswer>>,
  TError,
  {appId: string; id: string; data: CSAnswerRequest},
  TContext
> => {
  const mutationOptions = getUpdateCSAnswerMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 특정 CS에 대한 이메일을 전송합니다.
 * @summary CS 이메일 전송
 */
export const getSendEmailUrl = (appId: string, id: string) => {
  return `/admin/api/cs/${appId}/send-email/${id}`;
};

export const sendEmail = async (
  appId: string,
  id: string,
  options?: RequestInit,
): Promise<BooleanResponse> => {
  return customFetch<BooleanResponse>(getSendEmailUrl(appId, id), {
    ...options,
    method: 'POST',
  });
};

export const getSendEmailMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendEmail>>,
    TError,
    {appId: string; id: string},
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendEmail>>,
  TError,
  {appId: string; id: string},
  TContext
> => {
  const mutationKey = ['sendEmail'];
  const {mutation: mutationOptions, request: requestOptions} = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : {...options, mutation: {...options.mutation, mutationKey}}
    : {mutation: {mutationKey}, request: undefined};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendEmail>>,
    {appId: string; id: string}
  > = (props) => {
    const {appId, id} = props ?? {};

    return sendEmail(appId, id, requestOptions);
  };

  return {mutationFn, ...mutationOptions};
};

export type SendEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendEmail>>
>;

export type SendEmailMutationError = unknown;

/**
 * @summary CS 이메일 전송
 */
export const useSendEmail = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendEmail>>,
      TError,
      {appId: string; id: string},
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendEmail>>,
  TError,
  {appId: string; id: string},
  TContext
> => {
  const mutationOptions = getSendEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 특정 앱의 CS 목록을 조회합니다. 필터와 페이징 정보를 기반으로 검색이 가능합니다.<br/><br/>- 필터 조건은 JSON 형식으로 전달됩니다.<br/><br/>- 검색 가능 필드: clickKey, userId, adid, idfa, email<br/><br/>- 예시) {"clickKey":"abc123", "email":"user@example.com"}
 * @summary 앱별 CS 목록 조회
 */
export const getGetCSListUrl = (appId: string, params?: GetCSListParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/admin/api/cs/${appId}/list?${stringifiedParams}`
    : `/admin/api/cs/${appId}/list`;
};

export const getCSList = async (
  appId: string,
  params?: GetCSListParams,
  options?: RequestInit,
): Promise<CSListResponse> => {
  return customFetch<CSListResponse>(getGetCSListUrl(appId, params), {
    ...options,
    method: 'GET',
  });
};

export const getGetCSListQueryKey = (
  appId: string,
  params?: GetCSListParams,
) => {
  return [`/admin/api/cs/${appId}/list`, ...(params ? [params] : [])] as const;
};

export const getGetCSListQueryOptions = <
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetCSListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCSListQueryKey(appId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCSList>>> = ({
    signal,
  }) => getCSList(appId, params, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!appId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetCSListQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCSList>>
>;
export type GetCSListQueryError = unknown;

export function useGetCSList<
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  appId: string,
  params: undefined | GetCSListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSList>>,
          TError,
          Awaited<ReturnType<typeof getCSList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCSList<
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetCSListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSList>>,
          TError,
          Awaited<ReturnType<typeof getCSList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetCSList<
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetCSListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary 앱별 CS 목록 조회
 */

export function useGetCSList<
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  appId: string,
  params?: GetCSListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCSListQueryOptions(appId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary 앱별 CS 목록 조회
 */
export const prefetchGetCSList = async <
  TData = Awaited<ReturnType<typeof getCSList>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  appId: string,
  params?: GetCSListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSList>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetCSListQueryOptions(appId, params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * 특정 앱의 특정 상태의 CS 목록을 조회합니다. 필터와 페이징 정보를 기반으로 검색이 가능합니다.<br/><br/>- 필터 조건은 JSON 형식으로 전달됩니다.<br/><br/>- 검색 가능 필드: clickKey, userId, adid, idfa, email<br/><br/>- 예시) {"clickKey":"abc123", "email":"user@example.com"}
 * @summary 앱별 상태별 CS 목록 조회
 */
export const getGetCSListStatusUrl = (
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/admin/api/cs/${appId}/list/status/${status}?${stringifiedParams}`
    : `/admin/api/cs/${appId}/list/status/${status}`;
};

export const getCSListStatus = async (
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: RequestInit,
): Promise<CSListResponse> => {
  return customFetch<CSListResponse>(
    getGetCSListStatusUrl(appId, status, params),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getGetCSListStatusQueryKey = (
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
) => {
  return [
    `/admin/api/cs/${appId}/list/status/${status}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetCSListStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCSListStatusQueryKey(appId, status, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCSListStatus>>> = ({
    signal,
  }) => getCSListStatus(appId, status, params, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!(appId && status),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCSListStatus>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetCSListStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCSListStatus>>
>;
export type GetCSListStatusQueryError = unknown;

export function useGetCSListStatus<
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params: undefined | GetCSListStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListStatus>>,
          TError,
          Awaited<ReturnType<typeof getCSListStatus>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCSListStatus<
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListStatus>>,
          TError,
          Awaited<ReturnType<typeof getCSListStatus>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetCSListStatus<
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary 앱별 상태별 CS 목록 조회
 */

export function useGetCSListStatus<
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCSListStatusQueryOptions(
    appId,
    status,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary 앱별 상태별 CS 목록 조회
 */
export const prefetchGetCSListStatus = async <
  TData = Awaited<ReturnType<typeof getCSListStatus>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  appId: string,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetCSListStatusQueryOptions(
    appId,
    status,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * 특정 CS의 상세 정보를 조회합니다.
 * @summary CS 상세 조회
 */
export const getGetCSDetailUrl = (appId: string, id: string) => {
  return `/admin/api/cs/${appId}/detail/${id}`;
};

export const getCSDetail = async (
  appId: string,
  id: string,
  options?: RequestInit,
): Promise<CSViewResponse> => {
  return customFetch<CSViewResponse>(getGetCSDetailUrl(appId, id), {
    ...options,
    method: 'GET',
  });
};

export const getGetCSDetailQueryKey = (appId: string, id: string) => {
  return [`/admin/api/cs/${appId}/detail/${id}`] as const;
};

export const getGetCSDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  appId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCSDetailQueryKey(appId, id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCSDetail>>> = ({
    signal,
  }) => getCSDetail(appId, id, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!(appId && id),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCSDetail>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetCSDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCSDetail>>
>;
export type GetCSDetailQueryError = unknown;

export function useGetCSDetail<
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  appId: string,
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSDetail>>,
          TError,
          Awaited<ReturnType<typeof getCSDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCSDetail<
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  appId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSDetail>>,
          TError,
          Awaited<ReturnType<typeof getCSDetail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetCSDetail<
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  appId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary CS 상세 조회
 */

export function useGetCSDetail<
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  appId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCSDetailQueryOptions(appId, id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary CS 상세 조회
 */
export const prefetchGetCSDetail = async <
  TData = Awaited<ReturnType<typeof getCSDetail>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  appId: string,
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetCSDetailQueryOptions(appId, id, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * 모든 앱의 CS 목록을 조회합니다. 필터와 페이징 정보를 기반으로 검색이 가능합니다.<br/><br/>- 필터 조건은 JSON 형식으로 전달됩니다.<br/><br/>- 검색 가능 필드: clickKey, userId, adid, idfa, email<br/><br/>- 예시) {"clickKey":"abc123", "email":"user@example.com"}
 * @summary 전체 CS 목록 조회
 */
export const getGetCSListAllUrl = (params?: GetCSListAllParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/admin/api/cs/list?${stringifiedParams}`
    : `/admin/api/cs/list`;
};

export const getCSListAll = async (
  params?: GetCSListAllParams,
  options?: RequestInit,
): Promise<CSListResponse> => {
  return customFetch<CSListResponse>(getGetCSListAllUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getGetCSListAllQueryKey = (params?: GetCSListAllParams) => {
  return [`/admin/api/cs/list`, ...(params ? [params] : [])] as const;
};

export const getGetCSListAllQueryOptions = <
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  params?: GetCSListAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCSListAllQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCSListAll>>> = ({
    signal,
  }) => getCSListAll(params, {signal, ...requestOptions});

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getCSListAll>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetCSListAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCSListAll>>
>;
export type GetCSListAllQueryError = unknown;

export function useGetCSListAll<
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  params: undefined | GetCSListAllParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListAll>>,
          TError,
          Awaited<ReturnType<typeof getCSListAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCSListAll<
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  params?: GetCSListAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListAll>>,
          TError,
          Awaited<ReturnType<typeof getCSListAll>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetCSListAll<
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  params?: GetCSListAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary 전체 CS 목록 조회
 */

export function useGetCSListAll<
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  params?: GetCSListAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCSListAllQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary 전체 CS 목록 조회
 */
export const prefetchGetCSListAll = async <
  TData = Awaited<ReturnType<typeof getCSListAll>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params?: GetCSListAllParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCSListAll>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetCSListAllQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

/**
 * 모든 앱의 특정 상태의 CS 목록을 조회합니다. 필터와 페이징 정보를 기반으로 검색이 가능합니다.<br/><br/>- 필터 조건은 JSON 형식으로 전달됩니다.<br/><br/>- 검색 가능 필드: clickKey, userId, adid, idfa, email<br/><br/>- 예시) {"clickKey":"abc123", "email":"user@example.com"}
 * @summary 전체 상태별 CS 목록 조회
 */
export const getGetCSListAllStatusUrl = (
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/admin/api/cs/list/status/${status}?${stringifiedParams}`
    : `/admin/api/cs/list/status/${status}`;
};

export const getCSListAllStatus = async (
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: RequestInit,
): Promise<CSListResponse> => {
  return customFetch<CSListResponse>(getGetCSListAllStatusUrl(status, params), {
    ...options,
    method: 'GET',
  });
};

export const getGetCSListAllStatusQueryKey = (
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
) => {
  return [
    `/admin/api/cs/list/status/${status}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetCSListAllStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCSListAllStatusQueryKey(status, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCSListAllStatus>>
  > = ({signal}) =>
    getCSListAllStatus(status, params, {signal, ...requestOptions});

  return {
    queryKey,
    queryFn,
    enabled: !!status,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCSListAllStatus>>,
    TError,
    TData
  > & {queryKey: DataTag<QueryKey, TData, TError>};
};

export type GetCSListAllStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCSListAllStatus>>
>;
export type GetCSListAllStatusQueryError = unknown;

export function useGetCSListAllStatus<
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params: undefined | GetCSListAllStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListAllStatus>>,
          TError,
          Awaited<ReturnType<typeof getCSListAllStatus>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCSListAllStatus<
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCSListAllStatus>>,
          TError,
          Awaited<ReturnType<typeof getCSListAllStatus>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
export function useGetCSListAllStatus<
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {queryKey: DataTag<QueryKey, TData, TError>};
/**
 * @summary 전체 상태별 CS 목록 조회
 */

export function useGetCSListAllStatus<
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCSListAllStatusQueryOptions(
    status,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & {queryKey: DataTag<QueryKey, TData, TError>};

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary 전체 상태별 CS 목록 조회
 */
export const prefetchGetCSListAllStatus = async <
  TData = Awaited<ReturnType<typeof getCSListAllStatus>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  status: 'RECEIVED' | 'IN_PROGRESS' | 'ANSWERED',
  params?: GetCSListAllStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCSListAllStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetCSListAllStatusQueryOptions(
    status,
    params,
    options,
  );

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};
